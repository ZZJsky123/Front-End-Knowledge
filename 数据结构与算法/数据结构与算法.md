## 数据结构

```
【基本的数据结构】
1. 顺序储存   数组
2. 链式储存   链表

【场景数据结构】
1. 栈
2. 队列
3. 堆
4. 树
5. 图
数据结构的目的： 在特定场景下实现更高效的【增删改查】

【数据结构的访问方式】
1. 线性      【for/while】
2. 非线性    【递归】

数据结构是工具，算法是通过合适的工具解决特定问题的方法
```

```javascript
【大部分算法技巧，本质上都是树的遍历问题】
// 二叉树遍历框架 
function traverse(TreeNode root) {
    // 前序遍历 : 父节点 -> 左节点 -> 右节点
    traverse(root.left)
    // 中序遍历 ：左节点 -> 父节点 -> 右节点
    traverse(root.right)
    // 后序遍历 ：左节点 -> 右节点 -> 父节点
}

回溯动规分治专题，你就会发现只要涉及递归的问题，都是树的问题。

递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

【函数的定义】： 输入什么参数，返回什么数
```

```java
快速排序： 树的前序遍历
void sort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    int p = partition(nums, lo, hi);      // 通过交换元素构建分界点 p
    /************************/
sort(nums, lo, p - 1);
sort(nums, p + 1, hi);
}

归并排序： 树的后序遍历
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
    /************************/
}    
```


## 二叉树

```
【回溯、动归、分治】都是树的思维
【树的问题的难点】
 相邻子树的节点操作问题： 1. 同层相邻子树节点操作
                      2. 非同层相邻节点操作 

/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
【前序遍历】： 打印的第一个值是根节点，打印的第二个值是左子节点。           前序遍历的结果：  根节点 左子树 右子树 

【中序遍历】： 根据前序遍历确认根节点的位置，根节点左右分别为左子树和右子树。 后序遍历的结果：  左子树 子节点 右子树

【后序遍历】： 根节点被最后访问，遍历结果：左子树+右子树+根节点。(节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历)

【树的遍历的终止条件】：  return 
     1. root === null 遍历到尾节点
     2. root.left === null || root.right===null 遍历到尾节点的父节点
     
【树的构建】： 树的构建是链表相连的过程，这个过程不是线性。主要分为： 节点创造、节点赋值、递归返回左节点、递归返回右节点。
      a. [前序遍历] + [中序遍历] ： 前序遍历每一个元素代表当前子树节点 中序遍历提供该节点的左子树范围索引、右子树范围索引
      b. [中序遍历] + [后序遍历] ： 后序遍历倒序每个元素代表当前子树节点 中序遍历提供该节点的左子树范围索引、右子树范围索引
      c. [记录叶子节点的字符串]

【子树】：从当前节点开始一直到叶子节点过程中的所有节点称为子树。采用[后序遍历]的方式寻找二叉树上的所有子树

【重复】：树是二维，相较于一维的值相同，子树相同必须结构也相同。
比较二维相同可以将子树一维序列化，序列中值的顺序体现子树的结构。

【路径】：从根节点开始每次沿某个方向直到抵达叶子节点称为路径。
        路径的终点是某一节点两个子节点都是叶子节点。

【左右子节点】： 想同时对同层不同子树的两个节点操作必须获得这两个节点。

【BST数的种类】： 左子节点树 * 右子节点树

【二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么】。
```

```javascript
【翻转二叉树】： 同层节点作交换，即可完成翻转二叉树
 var invertTree = function(root) {
    if(!root){
        return null;
    }

    invertTree(root.left);
    invertTree(root.right);            // 树的后序遍历
    exChange(root);

    return root
};

function exChange(root){
     rLeft = root.left;
     rRight = root.right;

     temp = rRight;
     root.right = rLeft;
     root.left = temp;
}
```

**前序遍历+中序遍历得到二叉树信息**

![image-20210518205930388](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518205930388.png)

**进一步抽象**

![image-20210518210327674](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518210327674.png)

**后序遍历+中序遍历得到的二叉树数组信息**

![image-20210518212507796](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518212507796.png)

**进一步抽象**

![image-20210518212544305](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518212544305.png)

## 二叉搜索树

```
【特点】：

        1. 对于每一个节点node， 左子树节点的值比node值要小，右子树的节点值要比node值大。
        2. 分支为二
        3. 中序遍历结果有序
        
【常见BST】： AVL、红黑树(BST基础上引入平衡)、B+树

【中序遍历结果有序】： 
             function traverse(treeNode root){
                  if(root == null) return;
                  traverse(root.left);
                  print(root.val);
                  traverse(root.right)
              }

【BST的合法性】： 每个节点要大于其左子树的最大节点，要小于其右子树的最小节点。

【1-n个点多少种BST】： 选择数想x作为节点, 其左子树【1,x-1】数量x1,右子树【x+1, n】数量x2, 形成的节点树：x1*x2. 

【BST数的种类】： 左子节点树 * 右子节点树

【增】：与当前节点进行比较，小于向左子树，大于向右子树。

【删】：1. 当前节点无子节点：    直接删除
       2. 当前节点有一个子节点： 交换位置删除
       3. 当前节点有两个子节点： 找左子树最大或右子树最小

【查】

```

## 二叉堆

```javascript
二叉堆又称为： 完全二叉树

【数据结构】： 数组

【应用】： 堆排序、   优先队列

【类型】： 最大堆(父节点>子节点) 、  最小堆(父节点<子节点)

【基本操作】： 堆化、 加入(上浮操作)、 删除(下沉操作)

【代码】： 最大顶堆
  function BinaryHeap(num){
    this.length = 1;
    this.heap = [0];

    BinaryHeap.prototype.heapify = function(){
        for(let i of num){
            this.add(i);
        }
    }

    BinaryHeap.prototype.sink = function(i){
        let ll = this.length;
        while(2*i < ll){
            let j = 2*i;
            let right = 2*i+1;
            if(right < ll && this.less(j, j+1)) j++;
            if(!this.less(i, j)) break;
            this.exchange(i, j);
            i = j;
        }
    }

    BinaryHeap.prototype.swim = function(i){
        let cc = Math.trunc(i/2);
        while(i>1 && this.less(cc, i)){
            this.exchange(cc, i);
            i = Math.trunc(i/2);
            cc = Math.trunc(i/2);
        }
    }

    BinaryHeap.prototype.exchange = function(left, right){
        let temp = this.heap[left];
        this.heap[left] = this.heap[right];
        this.heap[right] = temp;
    }

    BinaryHeap.prototype.less = function(left, right){
        if((this.heap[left] - this.heap[right])<0){
            return true;
        }
        return false;
    }

    BinaryHeap.prototype.top = function(){
        if(this.heap.length > 1){
            return this.heap[1];
        }else{
            throw new Error("the length of heap less than 1");
        }
    }

    BinaryHeap.prototype.pop = function(){
        if(this.length <=1 ){
            return null;
        }
        let top = this.top();
        this.exchange(1, this.length-1);
        this.heap.pop();
        this.length = this.length-1;
        this.sink(1);
        return top;
    }

    BinaryHeap.prototype.add = function(val){
        this.heap.push(val);
        this.length = this.length+1;
        this.swim(this.length-1);
    }

    if(num.length > 0){
        this.heapify();
    }
}


```



## 二分搜索

```
【限制】: 针对的是已经排序的数组

【描述】：对于一维已经排序的数据，每次查看数组的中点，根据搜索目标进一步选择中点区间左侧或者是中点区间右侧，直到找到目标。

【代码框架】：
         function binarySearch(nums, target){
             let left = 0;
             let right = nums.length-1;
             
             while(left <= right){    // 此处是小于等于
                let mid = left + (right - left)/2;
                if(nums[mid] === target){
                    return mid;
                }else if(nums[mid] < target){
                    left = mid + 1;
                }else if(nums[mid] > target){
                    right = mid - 1;
                } 
             }
             return -1;  
         }

【左侧边界二分搜索代码框架】 : 
  [物理意义]： 小于target的元素个数

         function leftBinarySearch(nums, target){
             let left = 0;
             let right = nums.length-1;
             
             while(left <= right){    // 此处是小于等于
                let mid = left + (right - left)/2;
                if(nums[mid] === target){
                    right = mid - 1;
                }else if(nums[mid] < target){
                    left = mid + 1;
                }else if(nums[mid] > target){
                    right = mid - 1;
                } 
             }
             
             if (left === nums.length) return -1;
             return nums[left] === target ? left : -1;  
         }

【右侧边界二分搜索代码框架】: left 指针向前移两种情况： 1. nums[mid] = target  2. nums[mid]<target
       function rightBinarySearch(nums, target){
             let left = 0;
             let right = nums.length-1;
             
             while(left <= right){    // 此处是小于等于
                let mid = left + (right - left)/2;
                if(nums[mid] === target){
                    left = mid + 1;
                }else if(nums[mid] < target){
                    left = mid + 1;
                }else if(nums[mid] > target){
                    right = mid - 1;
                } 
             }
             if (right < 0) return -1;
             return nums[right] === target ? right : -1;  
         }

【实际问题】： 未知量可能取值是有序集合，例如[0, +00]利用二分搜索法快速定位满足限制条件的结果。

旋转数组： 在某个下标 K 处进行旋转，将下标从 K 处开始一直到末尾的数据 E ,旋转到数组开头。 
         [nums[0], nums[1], nums[2],...,nums[k],...,nums[E]]
                                |  发生旋转
         [nums[k], nums[k+1],...,nums[E],nums[0],nums[1],...,nums[k-1]]
 
         有序数组经过旋转后， 数组整体被分为两部分，以nums[0]为分界线，两部分相对有序。
 
 针对旋转数组搜索目标 target 
     
        方法1： 寻找 breakout ，随后在固定区间内完成搜索
               for(let i=0; i<nums.length-1; i++{
                  if(nums[i] > nums[i+1]){
                      break;
                  }
                  breakout = i + 1;   (初始化为0)
               }
               if(breakout == nums.length){
                  left  = 0;
                  right = breakout;
               }else if(nums[0] <= target){
                  left = 0;
                  right = breakout;
               }else{
                  left = breakout + 1;
                  right = nums.length - 1;
               }
               
          方法2： left = 0；  right = nums.length-1 在有序数组部分进行搜索
                
                if(nums[mid] == target) return mid;
                if(nums[left] <= nums[mid]){    前半部分有序
                  if(target >= nums[left] && nums[mid]<target)
                       right = mid -1
                   else    不在该区间中
                       left = mid + 1;
                
                }else if(nums[mid] < nums[right]){                       后半部分有序
                    if(target > nums[mid] && target <=nums[left])
                       left = mid +1;
                    else    不在该区间中
                       right = mid -1;
                }
二维矩阵搜索：
          矩阵特点： 整数从左到右按照升序排列
                   每行中第一个整数大于前一行中最后一个整数
          方法1：  二维矩阵一维化
                  let aa = martix.flat(infinity);
           
           方法2： 根据行首选择搜索行
                  let row = -1；
                  for(let i = 0; i<matrix.length; i++){
                     if(matrix[i][0] < target){
                        row++;
                     }else{
                        break;
                     }
                  }
寻找峰值：  前提数组中不存在相同数据
         方法1： 三指针
            pre = -1；
            cur = 0
            next = 1；
         
         方法2： 二叉搜索
         left = 0； right = nums.length -1;
         while(left < right){
            let mid = Math.trunc((left+right)/2);
            if(nums[mid] > nums[mid+1]){   局部下降，峰值在左边
                right = mid;
            }else{                         局部上升，峰值在 mid 之后
                left = mid + 1
            }
         }
         
         
       
```

## 回溯算法

```javascript
46：全排列  51：N皇后
【关键字】：暴力穷举算法、DFS算法

【步骤】：1. 路径：    已经做出的选择
        2. 选择列表： 你当前可以做的选择
        3. 结束条件： 到达决策树底层，无法再做决策的条件

        
【代码框架】：
result = []
function backtrack(路径， 选择列表){
        if(满足结束条件)｛
           result.push(路径);
           return
        ｝
        for(选择 in 选择列表)｛
          做选择
          backtrack(路径， 选择列表);
          撤销选择;
        ｝
}

【回溯算法的情景】： 一个人面前有【n条路：数据结构】，他需要选择【for遍历：计算机按顺序选择】出一条路径【记录路径：数据结构】， 第二次抵达分叉路口【递归】，依然有n条路径，但是他不能选择已经选择过的【数据结构：元素是否存在判断】，...第n个分叉口，他不用再做出选择，他会查看终点【判断条件】是否符合需求，符合【保留这条路径】，不符合回到上一个路口【递归返回】，重新选择路径【记录结构，抛出最后一个选】，进行下次遍历。

【回溯算法是多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作】。

【解决一个回溯问题，实际上就是一个决策树的遍历过程】
```

```javascript
【N皇后】： n*n维棋盘，一行为一个n叉路口，皇后进行路径选择【遍历】，记录路径【数据结结构】，抵达第n行【路径有效性判断】、回退到上一个节点，重新选择；若路径有效，则构建棋盘。
     【人的思维】：                     【机器思维】:
             1. 第一行选择1个位置             1. 第一行选择1个位置(遍历)
             2. 考虑规则                     2. 第二行选择第2个位置
                第二行选择第2个位置              位置的有效性判断 (规则代码化难点)
             n. 考虑规则                     n.第n行选择第n个位置
                第n行选择第n个位置               位置有效性判断。
             n+1: 回到起点                   n+1: 回到第n路口重新选择
             
var solveNQueens = function(n) {
     let res = [];
     let path = [];
     let branch = [];

     for(let i=0; i<n;i++){
         branch.push(i+1);     
     }

     nextCrossSelect(res, path, n, branch);

     return res;
};

function nextCrossSelect(res, path, n, branch){    

    if(path.length === n){
        let isRecoder = isValid(path);
        console.log(path, isRecoder)
       if(isRecoder){
           let checkerBoard=[];
           buildCheckBorder(checkerBoard, n, path)
           res.push(checkerBoard);
       }
       return ;

    }
    
    for(let i of branch){
        if(!path.includes(i)){
            path.push(i);
        }else{
            continue;
        }
        nextCrossSelect(res, path, n, branch);
        path.pop();
    }
}

function isValid(arr){

    if(arr.length === 1){
        return true;
    }else{

        // 右上方
        for(let i =0; i<arr.length; i++){
            let row =i-1; let cha =1;
            while(row >= 0){
                if(arr[row] === (arr[i]+cha)){
                    return false;
                }
                cha = cha+1;
                row = row -1;
            }
        }

        // 左下方
        for(let i =0; i<arr.length; i++){
            let row =i+1; let cha =1;
            while(row < arr.length){
                if(arr[row] === (arr[i]+cha)){
                    return false;
                }
                cha = cha+1;
                row = row +1;
            }
        }

        return true;
    }
}

function buildCheckBorder(board, n, path){
        for(let i=0; i<n; i++){
               let arr=[]; 
               for(let j=0; j<n; j++){
                  arr.push('.');
               }
               arr[path[i]-1]='Q';
               let str = arr.join('');
               board.push(str);
           }
}
```

## 动态规划

> ```javascript
> 509：裴波那契  322：零钱兑换
> 【关键字】：最值、穷举、处理最小重叠问题、正确的状态转移方程、循环迭代
> 
> 【最优子结构】：可以从子问题的最优结果推出更大规模问题的最优结果。
> 
> 【步骤】：
> 明确base case : 停止点，不再做选择
> 明确【状态】: 每次在路口上的指路牌类型(依据什么做选择)
> 明确【选择】: 分叉路口
> 定义dp数组/函数的含义
> 
> 【代码框架】
> # 初始化 base case
> dp[0][0][...] = base
> # 进行状态转移
> for 状态1 in 状态1的所有取值：
> for 状态2 in 状态2的所有取值：
> for ...
> dp[状态1][状态2][...] = 求最值(选择1，选择2...)
> 
> 
> 【悟】：计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。
> 
> 列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。
> ```
>
> ```javascript
> 【算法】：
> 
> 1. 裴波那契 : 第一年：1 ，第二年:1, 第n年：num(n-1)+num(n-2)
> 
> 普通递归版本： 时间复杂度o(2^n)
>    function fib(n){
>        if(n === 1 || n === 2) return 1; 
>        return fib(n-1)+fib(n-2)
>    }      
> 优化递归过程重叠子问题： 时间复杂度o(n)
>   function fib(n){
>       let memo = [0, 1, 1];
> 
>       if(n === 0) return 0;
> 
>       return optFib(memo, n);
>   }
> 
>   function optFib(memo, n){
>       if(memo[n]) return memo[n];
> 
>       memo[n] = optFib(memo, n-1) + optFib(memo, n-2);
> 
>       return memo[n];
>   }
> 
> 【零钱兑换】：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 
>       【选择】： 
>       【状态】： dp(amount)：当前面值需要的硬币数量
>       【base case】： amount = 0；
> 
>       function coinChange(coins, amount){
>           function dp(amount){
>               res = Number.MAXVALUE;
> 
>               if(amount <= 0){
>                  return amount===0? 1 : -1
>               }
> 
>               for(let coin of coins){
>                   subcount = dp(amount - coin);
>                   if subcount === -1 continue;
>                   res = min(res, 1+subcount)
>               }
> 
>               retturn  res!==Number.MAXVALUE? res : -1          
>           }
>          return dp(amount);
>       }
> 增加备忘录
>       function coinChange(coins, amount){
>           let memo = new Map();
> 
>           function dp(amount){
>               res = Number.MAXVALUE;
> 
>               if(memo.has(memo)) return memo.get(memo);
> 
>               if(amount <= 0){
>                  return amount===0? 1 : -1
>               }
> 
>               for(let coin of coins){
>                   subcount = dp(amount - coin);
>                   if subcount === -1 continue;
>                   res = min(res, 1+subcount);
>               }
> 
>                res !==Number.MAXVALUE? res : -1  
>                memo.set(memo, res);
>                return res; 
>           }
>          return dp(amount);
>       }
> 
> 
> 
> 【编辑距离】：(LeedCode代码 72) 给定两个字符串s1和s2，计算出符号是s1转换成s2所使用的最少操作次数。
> 
> 
> 【最长递增子序列】： 给定一个无序的整数数组，找到其中最长的上升子序列长度。  input:[10,9,2,5,3,7,101,18] 输出：4
> 
>    【核心】：正向思想和反向思想
> 
>    【正向思想】： 我的【选择】是以input数组每一个元素为起始点，向后查找。
>    【反向思想】： 我的【选择】是以input数组每一个元素为终点，向前查找。
> 
> 
>        【正向思想】：回溯算法  1. for 循环遍历岔路口  2. 确认每个岔路口记录的信息(一般声明为全局变量) 3. 递归进入下一个路口
>                        4. 重新选择路口时的回退操作。
>        /*
>         【选择】： nums元素作为起点，起点选定，下次岔路口不能包含已经选择的起点
>         【记录】： 路径长度+1： 当前节点+过去节点  (前置信息，无法用memo记忆数组减少递归)
>         【尽头】： 超出数组， 更新maxPath
>       */
>         var lengthOfLIS = function(nums) {
> 
>             let maxPath = 0;
>             let count = 0;
> 
> 
>             function dp(n, pre){
> 
>                  for(let i=n; i<nums.length; i++){
>                      if(pre >= nums[i]) continue;   // 【选择】
> 
>                      count = count + 1;             // 【记录】
>                      let res = dp(i+1, nums[i]);
>                      maxPath = Math.max(maxPath, res);       // 【更新最大值】
>                      count = count-1;                       //  【重新选择分叉口】
> 
>                                       }
>                  return count;
> 
>             }
> 
>             dp(0, -Number.MAX_VALUE);
>             return maxPath;
> 
>         };
> 
>       【正向思想】：动态规划   【加入字典后可在相应时间完成】
>        /*
>         【选择】： nums元素作为起点，起点选定，下次岔路口不能包含已经选择的起点
>         【状态】： 当前索引位置
>         【base case】：数组尽头
>         【后置信息】：当前位置的递增序列总长度
>       */
>       var lengthOfLIS = function(nums) {
> 
>           let memo = new Map();                  // 字典记录数组某个位置的后置信息
>           function dp(n, pre){
> 
>               let biggernum = 0;               
> 
>               for(let i=n; i<nums.length; i++){
>                   if(pre >= nums[i]) continue;   // 【选择】
> 
>                   if(memo.has(i)){
>                       biggernum = Math.max(biggernum, memo.get(i));
>                       continue;
>                   }
> 
>                   let fu = dp(i+1, nums[i]);    //  【状态】
>                   memo.set(i, fu+1);            
>                   biggernum = Math.max(biggernum, fu+1);
> 
>               }
>               return biggernum;
> 
>           }
>           return dp(0, -Number.MAX_VALUE);
>       };
> 
>       【反向思想】： dp数组， dp[i]表示以当前数为终点的最常递增子序列长度
>       function lengthOfLIS(arr){
> 
>          let dp = [].fill(1, 0, arr.length);
> 
>                     for(let i=0 ;i<arr.length; i++){
>              for(let j=0; j<i; j++){
>                  if(arr[i] > arr[j]){
>                     dp[i] = Math.max(dp[i], dp[j]+1)
>                  }
> 
>                               }
>           }
> 
>                     let res = 1;
>           for(let i of dp){
>               res = Math.math(res, i);
>           }
> 
>                     return res;
>       }
> 
>      };
> 
>          【二分查找解法】：
> 
> 【最大子数组合】：给定一个整数数组nums， 找到一个具有最大和的连续子数组(字数组最少包含一个元素， 返回其最大和)。
> 
>      【反向思想】： dp数组， dp[i]表示以当前数为终点的最大连续子数组和。
>       // 事件复杂度o(N), 空间复杂度o(N)
>       function maxSubArray(nums){
>           let dp = [];
>           let pre = -1;
>           let res = -Number.MaxValue;
> 
>                     for(let i=0; i<arr.length; i++){
>               if(pre < 0){
>                 dp[i] = nums[i] ;
>               }else{
>                 dp[i] = dp[i] + pre;
>               }
>               pre = dp[i];
>           }
> 
>                     for(let i of dp){
> 
>                             res = Math.max(res, i);
>           }   
>       }
>       // 可通过状态压缩，每次记录最大值而不需要dp数组。
>        function maxSubArray(nums) {
>             int n = nums.length;
>             if (n == 0) return 0;
>             // base case
>             int dp_0 = nums[0];
>             int dp_1 = 0, res = dp_0;
> 
>             for (int i = 1; i < n; i++) {
>                 // dp[i] = max(nums[i], nums[i] + dp[i-1])
>                 dp_1 = Math.max(nums[i], nums[i] + dp_0);
>                 dp_0 = dp_1;
>                 // 顺便计算最大的结果
>                 res = Math.max(res, dp_1);
>             }
> 
>             return res;
>         }
> 
> 【信封嵌套问题】：(LIS的变种) 给定一组宽度和高度都确定的数组(w, h)当另一个信封的宽度和高度逗比这个信封大时，这个信封就可以放进另一个信封里称为俄罗斯套娃。 计算有多少个信封能组成一组俄罗斯套娃问题。  [[5,4], [6,4], [6,7], [2,3]]
> 
>    【核心】： 对宽度排序，宽度相同高度按照降序排列， 随后对宽度使用LIS算法。
> 
>       function maxEnvelopes(nums){
>       Array.sort(nums, function(){
>           // 利用宽度进行比较
>       })
> 
>             let height = [];
>       for(let i of nums){
>            height.push(i[1]);
>       }
> 
>              return lengthLIS(height);    // 使用LIS算法
>    }
> 
> 【最长公共子序列 Longest Common Subsequence】
> 
> 1143 最长公共子序列： 输入两个字符串s1和s2, 请找出他们俩的最长公共子序列，返回这个子序列的长度。
>     【核心】： 由于是子序列，在匹配过程中只要存在相对顺序一致的元素即可，因此不需要以每个元素为起点，而是以第一个满足匹配的点作为【起点】，并更新下一个匹配字符。
>     【正向思想】： 
>      function longestCommonSubsequence(s1, s2){
> 
>                   let m = s1.length;
>          let n = s2.length;
> 
>                   function dp(arr1, i, arr2, j){
>              let res = 0;
> 
>                           if(i === m || j === n){
>                  return 0;
>              }
> 
>                           if(arr1[i] === arr2[j] ){
>                  res =1 + dp(arr1, i+1, arr2, j+1);
>              }else{
>                  t1 = dp(arr1, i, arr2, j+1);
>                  t2 = dp(arr1, i+1, arr2, j);
>                  res = Math.max(t1, t2);
>              }
> 
>                           return res;
> 
> 
>                       }
> 
>                   return dp(s1, 0, s2, 0);
>      }
>      [子序列问题]： 【正向思想】：以当前数为起点 : 回朔、动态规划 （记录的信息种类不同）
>              【反向思想】: 以当前数为终点 : 限制预估能力
> 
>              583 两个字符串的删除操作: 给定两个字符串s1和s2, 找到使得s1和s2相同所需要的最小步数，每步可以删除任意字符串中字符
> 
>          input: "sea" , "eat"
> output: 2
> 第一步将： 1. 将"sea"变为"ea", 第二步将"eat"变为"ea"
> 
>          【核心】： 找寻两个字符中的最大公共字符串， min = s1.lebgth-lcs+s2.length-lcs
> 
>            function minDistance(s1, s2){
> 
>            let lcs = longestCommonSubsequence(s1, s2)
> 
>           return (m-lcs+n-lcs);
>   }
> 
> 
> 712.【最长ASCII删除和】：给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和
> 
>     【核心】：最长公共子序列使两个字符删除的字符串最少
> 
>         【注意】： 当一个字符串为空时，另一个字符串全部都要删除
> 
>         function lobgestASCIIValue(s1, s2){
> 
>             function dp(s1, i, s2, j){
>         let res = 0;
> 
>                 f (i == s1.length()) {
>         // 如果 s1 到头了，那么 s2 剩下的都得删除
>         for (; j < s2.length(); j++)
>             res += s2.charAt(j);
>         return res;
>         }
>     if (j == s2.length()) {
>         // 如果 s2 到头了，那么 s1 剩下的都得删除
>         for (; i < s1.length(); i++)
>             res += s1.charAt(i);
>         return res;
>     }
> 
> 
>     if (s1.charAt(i) == s2.charAt(j)) {
>         // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除
>         res = dp(s1, i + 1, s2, j + 1);
>     } else {
>         // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个
>         res = Math.min(
>             s1.charAt(i) + dp(s1, i + 1, s2, j),
>             s2.charAt(j) + dp(s1, i, s2, j + 1)
>         );
>     }
>     return res;
> 
>             }
>    }
> 
> ```
> 
> **背包🎒问题**
>
> ```javascript
>【描述】: 一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
> 
> 【状态】： [选择的物品数量][背包可用容量] = [最大价值]
> 
> 【选择】： [最大价值] = max( 1. [物品数量-1][剩余容量]+val[当前物品] 
>                           2. [物品数量-1][背包可用容量]  
>                         )
> 
> 【代码】：
>         function bagPack(wt, val){
>             let dp = new Arrary(val.length+1).fill(0);
>             let i in dp{
>                 dp[i] = new Array(wt.length+1).fill(0); 
>             }
> 
>             for(let i=1; i<=val.length; i++){
>                 for (let w=1; w<=wt.length; j++){
>                      if(w - wt[i-1]<0){
> 
>                          dp[i][w] = dp[i-1][w];
> 
>                      }else{
> 
>                          dp[i][w] = Math.max(dp[i-1][w-wt[i-1]]+val[i-1], dp[i-1][w]);
> 
>                      }
>                 }
>             }
>             return dp[val.length][wt.length];
>         }
> 
> 【分割等和字集】：
> 
> 
> 【零钱兑换2】
> 
> ```
> 
> #### 贪心算法
>
> ```javascript
>【重叠】： 两个区间有公共部分称为重叠。 
>          如何判断重叠： 
>               a. 若对区间按照右半部分升序排序，则当前区间的end > 下一个区间的start，则重叠.
>               b. 若对区间按照左半部分降序排序，则当前区间的start < 下一个区间的end，则重叠.
> 
> 【无重叠区间】：[ [1,2], [2,3], [3,4], [1,3] ] 
> 
>     【应用】： 时间调度问题
> 
>     【核心】： 1. 按照截止时间对end升序排序， 此时相邻区间【重叠】的判断
>              2. 以最小end为参考删除与其重叠的区间
> 
> function eraseOverlapIntervals(intervals){
> 
>     intervals.sort(function (a, b){
> 
>         return a[1]-b[1];
>     });
> 
>     let x_end = intervals[0][1];
>     let count = 0;
> 
>     for(let i=1; i<intervals.length; i++){
> 
>         let start = intervals[i][0];
>         if(x_end > start){
>             count++;
>         }else{
>             x_end = intervals[i][1];
>         }
>     }
> 
>     return count;
> 
> }
> 
> 【最少数量箭引爆气球】： 
> 
> 【核心】： 
> 
> 【代码】：
>     var findMinArrowShots = function(points) {
>         points.sort( (a, b) => {
>             return a[1] - b[1]; 
>         })
> 
>         let x_end = points[0][1];
>         let count = 1;
> 
>         for(let i =1; i<points.length; i++){
> 
>               let start = points[i][0];
>               if(x_end >= start){
>                   count = count;
>               }else{
>                   x_end = points[i][1];
>                   count++;
>               }
>         }
>         return count
> };
> ```
> 
> 
>
> **股票买卖**
>
> ```javascript
>【核心】: 状态： 天数、 最多允许交易次数 、 是否持有股票
> 
>         状态方程：  dp[i][k][0] = MAx(dp[i-1][k][0],dp[i-1][k][1]+price[i]);
>                   dp[i][k][1] = MAX(dp[i-1][k][1], dp[i-1][k-1][0]-price[i]);
> 
>         basecase: dp[0][k][0] = 0;     第0天未交易未持有股票利润为0
>                   dp[0][k][1] = -Inf;  第0天未持有股票 不可能利润为 -Inf
>                   dp[i][0][1] = -Inf;  第i天最多允许交易次数为0，还持有股票，不可能
>                   dp[i][0][0] = 0;     第i天最对允许的交易次数为0，未持有股票
> 
> 【股票交易：1次最大利润】：
> 
>         var maxProfit = function(prices) {
>             let dp = new Array(prices.length+1).fill(-Number.MAX_VALUE);
> 
>             for(let i in dp){
>                 dp[i] = new Array(2);
>             }
> 
>             dp[0][0] = 0;
>             dp[0][1] = -Number.MAX_VALUE;
> 
>             for(let i =1; i<=prices.length; i++){
> 
>                 dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i-1]);
>                 dp[i][1] = Math.max(dp[i-1][1], -prices[i-1])   // 【注意】
>             }
> 
>             return Math.max(dp[prices.length][0], dp[prices.length][1]);
> 
> 
>         }
> 
> 
> 【股票交易：不限次数最大利润】：
>             输入: prices = [7,1,5,3,6,4]
>             输出: 7
>             解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>                  随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3
> 
>         var maxProfit = function(prices) {
>              let dp = new Array(prices.length+1).fill(-Number.MAX_VALUE);
> 
>              for(let i in dp){
>                  dp[i] = new Array(2);
>              }
>              dp[0][0] = 0;
>              dp[0][1] = -Number.MAX_VALUE;
> 
>              for(let i=1; i<=prices.length; i++){
>                  dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i-1]);
>                  dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i-1]);
>              }
> 
>              return Math.max(dp[prices.length][0], dp[prices.length][1]);
>         };
> 
> 【股票交易：不限次数冷却期最大利润】： 
>           [第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1] 
>     var maxProfit = function(prices) {
>         let dp = new Array(prices.length+1).fill(-Number.MAX_VALUE);
> 
>         for(let i in dp){
>             dp[i] = new Array(2);
>         }
>         dp[0][0] = 0;
>         dp[0][1] = -Number.MAX_VALUE;
> 
>         for(let i=1; i<=prices.length; i++){
>             dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i-1]);
> 
>             if(i>1){
>                 dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0]-prices[i-1]);
>             }else{
>                 dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i-1]);
>             }
>         }
> 
>         return Math.max(dp[prices.length][0], dp[prices.length][1]);
> };
> 
> 【股票交易： 不限次数有交易费用】
>       var maxProfit = function(prices, fee) {
>         let dp = new Array(prices.length+1).fill(-Number.MAX_VALUE);
> 
>         for(let i in dp){
>             dp[i] = new Array(2);
>         }
>         dp[0][0] = 0;
>         dp[0][1] = -Number.MAX_VALUE;
> 
>         for(let i=1; i<=prices.length; i++){
>             dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i-1]-fee);
>             dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i-1]);
> 
>         }
> 
>         return Math.max(dp[prices.length][0], dp[prices.length][1]);
> 
> };
> ```
> 
> 

### 枚举

> ```
> 【关键字】： 整数型常量字符集、不可删除
> 
> 【定义】：
>    数据表示：将String与Int结合，常量的标识符，可以Self-explain。
>    An enumeration type (also named an enumeration or an enum) provides an efficient way to define a set of named integral constants that may be assigned to a variable.
>    枚举将一组常量映射为一组数字，我们可以使用枚举方便的在字符常量和它的整型映射间进行切换。
> 
> 【Benefits】
> 1. Reduces errors caused by transposing or mistyping numbers.
> 
> 2. Makes it easy to change values in the future.
> 
> 3. Makes code easier to read, which means it is less likely that errors will creep into it.   代码可读
> 
> 4. Ensures forward compatibility. With enumerations, your code is less likely to fail if in the future someone changes the values corresponding to the member names.
> ```

### 链表

> ```javascript
> 92. 反转链表
> 
> 【核心】 1. 最终返回反转之后新的头结点
>         2.  
> 
> 【递归】： 时间复杂度O(N), 空间复杂度O(N)
>       function reverse(head){
>            if(head.next === null){
>                return head
>            }
>            let last = reverse(head.next);
>            head.next.next = head;
>            head.next = null;
>            return last;
>    }
> 
> 【核心】：  1. head.next 指向的是下一个节点
>             head.next.next 下一个节点的next
>           2. 反转要求的是下一个节点的next指向其上一个节点
>              上一个节点的next 指向 null
>              head.next.next = head;
> 
> 
> 【迭代】： 时间复杂度O(N) 空间复杂度O(1)
>          function reverse(head){
>              let pre = null;
>              let nxt = null;
>              let cur = head;
>              while (cur !== null){
>                  nxt = cur.next;
>                  cur.next = pre;
>                  pre = cur;
>                  cur = nxt;
>              }
>              return pre;   
>          }
> 
>   var reverseList = function(head) {
>         if(!head){
>            return head;
>         }
>         let pre = null;
>         let cur = head;
>         let next = head.next;
> 
>         while(cur.next !== null){
>              cur.next = pre;
>              pre = cur;
>              cur = next;
>             if(next)   next = next.next;
>         }
> 
>         return pre;
>     };
> 【核心】： pre是最后反转出的头节点
> 
> 
> 【链表前N反转】：给定一个索引区间[1, n](索引从1开始)， 反转链表
>         【m=1】 
>               let successor = null;
>               function reverseN(head, successor, n){
>                   if(n === 1){
>                       successor = head.next;
>                       return head;
>                   }
> 
>                   let last = reverseN(head.next, n-1);
> 
>                   head.next.next = head;
>                   head.next = successor;
>                   return last
>               }
> 
> 【链表部分反转】：给定一个索引区间[m, n](索引从1开始)， 反转链表
>       【m>1】
>         function reverseBetween(head, successor, m, n){
>              if(m === 1){
>               return  reverseN(head, successor, n)
>              }
>             head.next = reverseBetween(head.next, successor, m-1, n-1);
>             return head;
>          }
> 
>      迭代法：
>             var reverseBetween = function(head, left, right) {
>                 if(!head || !head.next) return head;
> 
>                 let pre = null;
>                 let cur = head;
>                 let next = head.next;
>                 let nhead = head;
> 
>                 let ii = 1;
>                 while(ii <= right && cur){
>                    if(ii < left){
>                       pre = cur;
>                       cur = next;
>                       next = next.next;
>                    }else if(ii >= left && ii <= right){
>                      if(ii === left) nhead = pre; 
>                      cur.next = pre;
>                      pre = cur;
>                      cur = next;
>                      if(next) next = next.next;
>                    }
>                    ii++;
>                 }
> 
>                if(left !== 1){
>                  nhead.next.next = cur;
>                  nhead.next = pre;
>                }else{
>                  head.next = cur;
>                  head = pre;
>                }
>                 return head;
>             };
> 
> ```
>
> 当 m = 1;
>
> ![img](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/7.jpg)
>
> ```javascript
> 25 K个一组翻转链表  困难
> 
>   【】：
>        function reverseGroup(head, k){
>            let a=head; let b=head;
>            for(let i =0; i<k; i++){
>               if(b === null) return head;
>               b = b.next;
>            }
> 
>            let newHead = reverse(a, b);
>            a.next = reverseGroup(b, k);
>            return newHead
>     }
>  【】： 递归的截止条件是剩余的节点数不足K个
> 
>  【递归思考什么】： 1. 构建递归函数中执行的参数，返回值
>                 2.  划分功能部分
>                 3.  设置截止条件
>                 4.  将框架带入到首节点，空节点，尾节点
>  弄明白输入信息 - 弄明白返回值 - 弄明白功能 - 写成代码
> 
> ```
>
> ```javascript
> 234 回文链表
> 
>  【特点】： 回文串关于中间对称，正读和倒读一致
> 
>  【寻找回文串】: 从中间向两端逼近     长度未知
> 
>  【判断回文串】：从两端向中间逼近     字符串长度已知
>      【思路】： 1. 双指针技巧      【索引】
>               2. 后向遍历思想
> 
> 
>  【判断回文单链表】:
>               1. 链表反转
>               2. 后序遍历 (入栈出栈操作)
> 
> ```
>
> ```javascript
> 【双指针】
> 141 环形链表 
> 142 环形链表||
> 167 两数之和||
> 344 反转字符串
> 19  删除列表倒数第N个元素
> 
> 【快慢指针】：链表中的问题  ： 常用于一维线性结构，快指针有预盼的用处。
> 
>      1. 判断链表中是否有环： 快慢指针相同起点，若存在环快指针会与慢指针相遇，不存在快指针先抵达终点。
>      function isCycle(head){
>           let slow = head;
>           let fast = head;
> 
>         while(fast !== null && fast.next !==null){
>             fast = fast.next.next;
>             slow = slow.next;
>             if( fast === slow) return true;
>         }
> 
>          return false;
>      }
> 
>      2. 已知链表中有环，返回这个环的起始位置： 快慢指针相遇后，停止循环，将慢指针移动回head节点，快慢指针同步移动，再次相遇为起点节点。 未知量x：起始环节点， 设相遇点距x为m，慢指针走到相遇点共用k步，则head距相遇点：k-m; 快指针走了2k步，环内走的步数：2k-(k-m)=k+m; 从x到相遇点共走2m步， 从相遇点到x共k+m-2m=k-m步。 因此算法成立
>       function  detectCycle(head){
>           let slow=head;
>           let fast=head;
>           while(!fast && !fast.next){
>               fast = fast.next.next;
>               slow = slow.next;
>               if(fast === slow) break;
>           }
> 
>           if(!fast || !fast.next) return null;
> 
>           slow = head;
>           while(slow !=== fast){
>               slow = slow.next;
>               fast = fast.next;
>           }
>           return slow;
>       }
> 
>     3. 寻找链表中点： 慢指针走到middle， 快指针走到end
>     function middleNode(head){
>          let fast, slow;
>          fast=slow=head;
> 
>         while(!fast && !fast.next){
>             fast = fast.next.next;
>             slow = slow.next;
>         }
> 
>         return slow;
>     }    
>        链表中点实现链表的二分问题。
> 
>    4. 寻找链表的倒数第n个元素： 开始时快慢指针相差n个位置，则他们同速前进，快指针抵达null后，慢指针同时也抵达倒数第n个位置
>       function deleteN(head, n){
>           let slow = head;
>           let fast = head;
> 
>           while(n-- > 0 ){
> 
>               fast = fast.next;
>           }
> 
>           if(!fast) return head.next;  // 说明倒数n个节点就是第一个节点
> 
>           while(!fast && !fast.next){
> 
>               fast = fast.next;
>               slow = slow.next;
> 
>           }
>          slow.next = slow.next.next;
>          return head;
>       }
> 
> 
> 【左右指针】：数组/字符串的问题
> 
>       1. 二分查找
> 
>       2. 两数之和：升序数组，找到两个数相加和等于目标数，函数应该返回两个下标值且 index1<index2   
>         【思想】：最大+最小 < target  left++
>                 最大+最小 > target  right--
> 
> 
>       3. 反转数组   循环截止条件： left < right
> 
>       4. 滑动串口问题： 解决字符串匹配问题
> 
> 
> ```
>
> ![img](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/2.jpeg)

### 数组

```javascript
【左右指针】：数组/字符串的问题

      1. 二分查找
      
      2. 两数之和：升序数组，找到两个数相加和等于目标数，函数应该返回两个下标值且 index1<index2   
        【思想】：最大+最小 < target  left++
                最大+最小 > target  right--
         
      
      3. 反转数组   循环截止条件： left < right

      4. 滑动串口问题： 解决字符串匹配问题
```

```javascript
【O(1)时间删除/查找数组中的任意元素】

380 常数时间插入、删除和获取随机元素
710 黑名单中的随机数(困难)

【常数时间插入/删除任意元素】： 实现一个数据集合，插入元素：val不存在在集合中，插入并返回true； 如果val在集合中，删除并返回true， 从集合中等概率随机获得一个元素。  时间复杂度o(1)
        1. 步骤1： 确认底层数据结构
           哈希表：插入、删除时间复杂度为o(1)，但是无法等概率随机获得一个元素。
           数组： 满足等概率返回元素， 如何插入和删除时间复杂度为o(1), 插入时向数组最后的节点处插入；删除与尾元素交换，再pop
        2. 步骤2： 底层数据结构为数组
                  利用哈希表记录索引-值，利用哈希表判断元素是否存在，不存在将元素push进数组中，并用哈希表记录。 按值删除时，从哈希表中取出索引值， 修改尾元素索引记录后，数组交换并使得长度减一
                  

【避开黑名单中的随机数】：    url会经常使用到黑名单
给你输入一个正整数 N，代表左闭右开区间 [0,N)，再给你输入一个数组 blacklist，其中包含一些「黑名单数字」，且 blacklist 中的数字都是区间 [0,N) 中的数字
class Solution {
public:
    // 构造函数，输入参数
    Solution(int N, vector<int>& blacklist) {}
    
    // 在区间 [0,N) 中等概率随机选取一个元素并返回
    // 这个元素不能是 blacklist 中的元素
    int pick() {}
};


```

```javascript
【有序数组的重复元素】

26. 删除排序数组中的重复项   （简单）
83  删除排序链表中国的重复元素 (简单)
27. 移除元素 （简单）
283 移动零

1. 有序数组/链表去重
    
【核心】： 删除重复的元素且不改变数组的有序性  双指针

【方法】： 1. 遇见重复的将其设为最大值，最后排序 复杂度o(NlogN)
         2. 快慢指针，快指针走在前面遇见不重复的，slow索引+1，并将slow对应的值设置为fast对应的值，fast遍历完，[0，slow]就是不重复的值。
   function deleteDuplicate(arr){
       if(arr.length === 0){
              return 0;
       }
       let slow = 0 ;
       let fast = 1;
     while(fast < arr.length){
         if(arr[slow] !== arr[fast]){
              slow++;
              arr[slow] = arr[fast];
         }
         fast++;
     }  
       return slow++;
   }


  链表去重
  function deleteDuplicate(head){
      if(!head){
          return null;
      }
      
      let slow = head;
      let fast = head.next
      
      while(!fast ){
          if(slow.val !== fast.val){
               slow = slow.next;
               slow.val = fast.val;
          }
          fast = fast.next;
      }
      slow,next = null;
      return head;
  }

2.原地移除元素  【双指针】

【方法】： slow 和 fast同一个起点，若没有遇到target则同行，若遇见fast+1，下次循环到来判断slow是移动还是静止

  function deleteElement(arr, target){
      if(arr.length <= 0) return arr;
      
      let slow = 0;
      let fast = 0;
      while(fast < arr.length){
           if(arr[fast] != target){
    
               arr[slow] = arr[fast];
               slow ++;
           }
           fast = fast+1;
    }
      return slow+1;
  }

3. 移动零; 将数组中国的0移动到末尾

   【思路】:双指针， 先将0从前面移除，再根据返回的索引将数组后面的元素设置成为0.
```

```javascript
【twoSum问题的核心思想】 哈希表解决问题   JSMAp数据集如何遍历

1. 两数之和（简单）： 返回两个数的索引
  function twoSum(arr, target){
       let map = new Map();
       let count = 0;
       for(let i of arr){
           map.set(i, count++);  // 相同元素会发生索引覆盖
       }
       for(let i in arr){
           val = target-arr[i];
           if(map.has(val) && map.get(val) != i){
           return [].push(i,map.get(val));   
       }
       return [-1 -1]
       
       
  } 

2. 两数之和III- 数据结构设计

a. 使用HashMap 时间复杂度o(N)  空间复杂度o(N)
      
      function TwoSum(){};
      Twosum.prototype.hashMap = new Map();
      
      TwoSum.prototype.add = function(value){
          let self = this;
          
          if(hashMap.has(value)){
             hashMap.set(value, hashMap.get(value)+1); 
          }else{
              hashMap.set(value, 1);
          }
          
      }
      TwoSum.prototype.find = function(value){
          let self = this;
          let arr = self.hashMap.keys();

          for (let i of arr){
              val = target - i;
              if(val === arr[i] && self.hashMap.gets(val)>1){
                  return true;
              }
              if(self.hashMap.get(val)){
                  return true;
              }
          }
          return false
      }
      

b. 数据结构设计- API1 add
               API2 find     时间复杂度o(N)
               
【针对使用find频繁的场景优化】
```

### 双指针

```javascript
 2数之和
      a. 数组无序， 用 map 数据结构辅助
      
      b. 数组排序后， 用双指针   (推荐)
      
          nums.sort((a, b) => {
             return a-b;
          })
          let left = 0;  let right = nums.length-1;
          while(left < right){
             if(nums[left] + nums[right] > target){
                 right--;
             }else if(nums[left] + nums[right] < target){
                 left++;
             }else{
                return  res.push(left, right);
             }
          }
          变形： 若收集所有组合，且不能有重复
          let left = 0;  let right = nums.length-1;
          while(left < right){ 
             let lv = nums[left];
             let rv = nums[right];
             sum = lv + rv;
             if( sum > target){
                 right--;
             }else if( sum < target){
                 left++;
             }else{
                 let temp = [lv, rv];
                 res.push(temp)
                 while(left < right && nums[left] == lv) left++;
                 while(left < right && nums[right] == rv) right--;
             }
          }
          return res; 

三数之和： 
             while(let i < nums.length){
                 let lv = nums[i]
                 let truple = toSum(nums, i+1, target-lv);
                 for(let i=0; i<truple.length; i++){
                     let temp = truple[i];
                     temp.push(nums[i]);
                     res.push(temp)
                 }
                 while(i< nums.length && nums[i] == lv) i++;   // 防止重复保证送入不同的起始数。
             }
          

```



###  滑动窗口

```javascript
76. 最小覆盖子串(困难)    【游戏】: 搬运黄金， 需要两个人

567.字符串的排列(中等)

438. 找到字符串中所有字母异位词

3. 无重复字符的最长子串（中等）
 
27. 移除元素

. 删除排序链表的重复元素

【滑动窗口框架】：
    function sildWinodow(str, template){
         let left = 0;
         let right = 0;
         let goldMap = new Map();
         let sWindow = new Map();
        
        while(right < template.length){
            //  滑动窗口扩张
               right++;
            while(收缩条件){
                // 滑动窗口收缩
               left++;
            }
        }
     
    }
   【核心】： 1. 确定窗口长度大小（即什么时候不扩张）
            2. 确定窗口收缩停止条件
    
   【游戏】： 一条单方向石板路径，下方埋着黄金或者石块，两人寻找金块，上帝约定只能拿走固定金块数目，且必须连同子路径石块一起搬走。两个人决定保险起见寻找到最短路径上。
   
   【步骤】： 1.初始化left=right=0;  索引左闭右开区间[left， right)
            2.不断增加right指针扩大窗口[left, right),直到窗口中字符串符合要求。
            3. 停止增加right， 前进left指针，缩小窗口，直到[left， right）窗口不符合要求，期间若遇见新的满足序列的子字符串记录
            4. 重复步骤2、3直到right达到字符串尽头。

1. 给定一个字符串S， 一个字符串T，请找出字符串S中包含T的最小子串(题目保证最小子串唯一)
   【关键点】： 子串包含T中所有字符，希望它最小
   
   【方法】： 1. 两层for循环，从左向右将每个字符都作为起点计算包含T的最小字符串长度   时间复杂度o(N^2)
          for(let i =0; i<arr.length;i++){
             for(let j=i+1;j<arr.length;i++){
                 // 伪代码
                 if [i:j] exist t 所有字母
                     记录长度
                     跳出循环
             }
          }
【滑动串口】   2. function minWindow(str, template){
                 let goldMap = new Map();
                 let slideWindow = new Map();
                 let left = 0; let right = 0;  let valid=0;
                 let start = 0; let len = str.length;
                 let strr = Array.from(str);
                 let temp = Array.from(template);
    
                 for(let i of temp){
                    if(map.has(i)){
                        map.set(i, map.get(i)+1);
                    }else{
                       map.set(i, 1);
                    }
                 }
                 
                 while(right < strr.length){
                     let c = strr[right];
                     
                     right++;
                     
                     if(goldMap.has(c)){
                          if(slideWindow.has(c)){
                      slideWindow.set(c, map.get(c)+1);
                          }else{
                       slideWindow.set(c, 1);
                          }
                 if(slideWindow.get(c) === goldMap.get(c)){
                     valid++ ;
                 }        
   
                  while(valid === template.length){
                      let c2 = strr[left];
                      
                        if(len < (right - left)){
                              len = right -left;
                              start = left
                          }
                           
                      if(goldMap.has(c2)){
                             
                         if(slideWindow.get(c2) === goldMap.get(c2)){
                             valid--;
                         }                   
                          
                          slideWindow.get(c2)=slideWindow.get(c2)-1;
                          if(slideWindow.get(c2) === 0) slideWindow.delete(c2);
                      }
                          
                      left++;
                  }   
                      
                 }
                 
                  return len === Number.MaxValue ?"":strr.slice(start, start+len);
                 
              }   
 
    2. 字符串排列:给定两个字符串s1和s2,判断s2是否含有s1的子串
          
         function checkInclusion(template, str){
                  let left=0;
                  let right =0;
                  let valid = template.length;
                  let goldMap = new Map();
                  let sWindow = new Map();
                  
                  let strr = Array.from(str);
                  let tem  = Array.from(template);
                  
                  for(let i of tem){
                        if(goldMap.has(i)){
                            goldMap.set(i, goldMap.get(i)+1);
                        }else{
                            goldMap.set(i, 1);            
                        }
                  }
                  
                  while(left < arr.length){
                     let c = strr[right]; 
                      
                      right ++;
                      // 进行窗口内数据的一系列更新
                      if(goldMap.has(c)){
                        if(sWindow.has(c)){
                           sWindow.set(c，sWindow.get(c)+1;
                        }else{
                            sWindow.set(c, 1);
                           } 
                        if(sWindow.get(c)===goldMap.get(c)){
                            valid++;
                        }  
                        
                      }
                      
                      while(right - left>=tem.length){
                          if(valid === tem.length){
                              return ture;
                          }
                          
                          let c2 = strr[left];
                          left++;
                          if(goldMap.has(c2)){
                              if(goldMap.get(c2) === sWindow.get(c2)){
                                  valid--;
                                 sWindow.get(c2)=sWindow.get(c2)-1;
                              }
                          }
                          
                      }
                      return false;
                  }
                  return false
              }
    
    3. 最长无重复子串： 给定一个字符串，找出其中不含有重复字符的最长子串的长度
       function lengthOfLongestSubstring(str){
          let right = 0;
          let left = 0;
          let sWindow = new Map();
          let len = 0;
          let strr = Array.from(str);
          
          while(right < str.length){
              let c = strr[right];
              right ++
              if(sWindow.has(i)){
                  sWindow.set(c, sWindow.get(i)+1);
              }else{
                  sWindow.set(c, 1);
              }
              
              
              while(sWindow.get(c)>1){
                  if(len< right - left ){
                     len = right - left
                  }
                  let c2 = str[left]
                  left ++;
                  sWindow.set(c2, sWindow.get(c2)-1);
              }
                   
          }
           return len;
       }

```

```javascript
3. 无重复字符的最长子串（中等）

    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度
    输入: s = "abcabcbb"
    输出: 3 
    解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
    
 【核心】： 子串、 不重复、 最长
 
 【思路】： 滑动窗口生成左右指针， left和right指针初始在索引0处， right向前遍历
      在遍历过程元素加入到一个Map结构中，遇见Map中重复的，修改元素在map中对应的数量
      left进行滑动，滑动截止的条件是该元素数量<=1。
      
 【代码】：
 var lengthOfLongestSubstring = function(s) {
    if(s.length <= 0){
      return 0;
    }

    let map = new Map();
    let slow = 0;
    let fast = 0;
    let ll = 1;

    s = Array.from(s);

    while(fast < s.length){
      let c = s[fast];
      
      if(!map.has(c)){
          map.set(c, 1);
          fast++;
      }else{
          ll = Math.max(ll, fast - slow);
          map.set(c, map.get(c)+1);      
          while(map.get(c) > 1){
              let d = s[slow];
              slow++;
              map.set(d, map.get(d)-1);
          }
          fast++;
      }
    }

    ll = Math.max(ll, fast - slow);
    return ll;
}

 26. 删除有序数组的重复项
  【题目】：  
     给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
  【核心】： 有序。
  
  【思路】：
     【额外空间】： 新创建一个数组A， 将与A中现在不重复的元素加入其中。
     【滑动窗口】： 创建left指针和right指针，left=0， right=1，窗口固定长度1，若left指针与right指针
                  不同left和right同时移动,  若相同right++，left保持不动，直到再次不同left++并进行
                  元素交换。
                  
  【代码】：left始终指向无重复元素的末尾。
      var removeDuplicates = function(nums) {
       let slow = 0
       let fast = 0;

       while(fast < nums.length-1){
           fast++;
           if(nums[fast] !== nums[slow]){
               slow++;
               nums[slow] = nums[fast];
           }
       }

       return slow+1;
    };
 316. 去除重复字母
    给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小
    
   【核心】： 字符串是无序的， 无法使用双指针。 字典序最小(最大程度保证有序)
   
   【思路】：用map数组记录字符串中每个元素出现的次数， 从起点开始将元素加入到新建数组A中，新元素进入与尾
            元素进行比较比它小(且后面还存在当前尾元素)将其剔除。
    
   【代码】： 
   
       var removeDuplicateLetters = function(s) {
        s = Array.from(s); 
        let map = new Map();
        let res = [];

        for(let i of s){
            if(!map.has(i)){
                map.set(i, 1);
            }else{
                map.set(i, map.get(i)+1);
            }
        }

        for(let i of s){
           if(!res.includes(i)){
               while(res.length>0 && res[res.length-1]>i && map.get(res[res.length-1])>0){
                   res.pop();
               }
               res.push(i);
           }
           map.set(i, map.get(i)-1);

        }
      //  console.log(res.includes('b'));
        return res.join('');

    };

27： 移除元素
var removeElement = function(nums, val) {
     let slow = 0;
     let fast = 0;

     while(fast < nums.length){
          let c = nums[fast];
           
           if(c !==val){
               nums[slow] = nums[fast];
               slow++;
           }
           fast++;
     }

     return slow;
};
```



```
我将【数组】 【链表】 【哈希表】 【栈】 【队列】 【树】【堆】在我心里的心里表征是什么？
```

### LRU

```javascript
【数据结构】：  哈希表+链表 --- 哈希链表
    
    【基本操作】：执行【添加】【查询】【删除】。时间复杂度o(1)
    
    【特点】： 容量固定，抵达上限时优先删除最少访问的数据。
    
    【操作说明】： 双向链表存储key-value， 哈希表存储key， 插入时利用哈希判断是否存在，不存在直接向【队尾添加】； 访问时，通过【Hash表返回键值】，并将其从【hash表中删除】【向列尾添加】。
    
    【核心】： 不常访问的数据在LRU队首， 上一次访问的数据在LRU队尾。
    哈希表为LRU提供数据查询功能，因为链表的数据查询时间复杂度o(N)
    
   class LRU(){
       
       constructor(n){
           this.map = new Map();
           this.cache = new biList();
           this.size = n;
           this.count = 0;
       }
  
       get(key){
           if(!this.map.has(key)){
               return -1;
           }
           let node = this.cache.removeNode(key);
           this.cache.add(key, key.val);
       };
       
       put(key, val){
           if(this.map.has(key)){
               key.val = val;
               return;
           }
           if(this.count>this.size){
              let k = this.cache.removeFirst();
                  this.map.delete(k.val);
           }
           
           this.cache.add(key, val);
           this.map.set(key, val);
           
       };
       remove(Node){
           
           this.cache.remove(Node);
           this.map.delete(Node);
       };
   }
   
   class biList(){
       constructor(){
          this.head = new biNode();
          this.last = new biNode();
          this.head.next = this.last;
          this.last.pre = this.head;
          this.size = 0;
       }
       addLast(){}
       addFirst(){}
       removeNode(){}
       removeFirst(){}
   }

   class biNode(){
       
       constructor(key, val){
           this.next = null;
           this.pre = null;
           this.key = key || null;
           this.val = val || null ;
       }
   }

【】： 数据的优先级按照时间排序
```

### LFU

```javascript
【基本操作】： 【查询】【增添】【删除】

【特点】：执行查询操作时，存在返回查询值，不存在返回-1。 执行添加操作，如果key已存在则将它对应的值改为val；如果key不存在，则插入的键值(key, val)当缓存达到容量capacity时，删除使用频次最低的键值对，如果有多个键值对，则删除最旧的那个

【查询】： 按照键值查询， 访问次数+1
【增添】： LFU未满： 新元素，直接添加频次设为1
                  老元素，修改并获得频次，频次加1
         LFU已满： 首先删除频次最低的元素， 若存在多个则删除时间旧的

【核心】： 1. 频率是第一删除标准  2. 频率相同比较时间 (双向链表)
          
【数据结构设计】：  1. hashMap   key -> value
                2. freToKey   fre -> biList
                3. keyToFreq  key -> freq
                4. minFreq    记录最小值

【代码框架】：
      function LFUCache(){
       
       constructor(n){
          this.hasMap = new Map();
          this.keyToFre = new Map();
          this.freToKey = new  Map();
          this.cap = n;
          this.minFreq = 0;
       
       }
       get(key);
       put(key, val)；
      }
      
}
【get】：     检测kv表是否为空，不为空KV表返回值
             increase freq
             
【put】:      1. 检查是否是存在元素，是修改值， increase freq，返回
             2. 检查LFU是否满，满了执行removeMinFreqKey()
             3. 添加新元素， kv表更新， kf 新增 key -> 1
                           fk 新增
         
【increaseFreq】:         
             private void increaseFreq(int key) {
                int freq = keyToFreq.get(key);
                /* 更新 KF 表 */
                keyToFreq.put(key, freq + 1);
                /* 更新 FK 表 */
                // 将 key 从 freq 对应的列表中删除
                freqToKeys.get(freq).remove(key);
                // 将 key 加入 freq + 1 对应的列表中
                freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
                freqToKeys.get(freq + 1).add(key);
                // 如果 freq 对应的列表空了，移除这个 freq
                if (freqToKeys.get(freq).isEmpty()) {
                    freqToKeys.remove(freq);
                    // 如果这个 freq 恰好是 minFreq，更新 minFreq
                    if (freq == this.minFreq) {
                        this.minFreq++;
                    }
                }
}

【removeMinFreqKey】:
private void removeMinFreqKey() {
            // freq 最小的 key 列表
            LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
            // 其中最先被插入的那个 key 就是该被淘汰的 key
            int deletedKey = keyList.iterator().next();
            /* 更新 FK 表 */
            keyList.remove(deletedKey);
            if (keyList.isEmpty()) {
                freqToKeys.remove(this.minFreq);
                // 问：这里需要更新 minFreq 的值吗？
            }
            /* 更新 KV 表 */
            keyToVal.remove(deletedKey);
            /* 更新 KF 表 */
            keyToFreq.remove(deletedKey);
        }
```

### 栈

```javascript
496. 下一个更大元素I
503. 下一个更大元素II
739. 每日温度

【单调栈】： 栈，但是每次新元素入栈后栈内元素都保持有序。

 【核心】： 在加入元素时对栈顶元素做判断，不符合大小关系出栈

496. 下一个更大的元素I （简单）
503. 下一个更大元素II (中等)
739. 每日温度 (中等)

1. 下一个更大的元素I： 输入一个数组 nums = [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。 返回访问元素中下一个最大的数字 无返回-1
  
   【思路1】： 暴力解法o(N^2)
   
   【思路2】： 倒着入栈，若元素小出栈
   
   function nextGreatElement(arr){
       
       let res =[];
       let s = [];
       
       for(let i =arr.length-1; i>=0; i--){
             
             while(!s.length && s[s.length-1]<arr[i]){
                 s.pop();
             }
             res[i] = s.length?-1:  s[s.length-1];
             s.push(arr[i]);
       
       }
       return res;
      
   }

2. 每日温度：给你一个数组 T，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0。

     function dailyTemperatures(arr){
        let res =[];
        let s = [];
        int index =arr.length;
        
        for(let i=arr.length; i>0; i--){
        
           while(!s.length && s[s.length-1]<arr[i]){
               
               index = i;
               s.pop();
               
           }
        
           res[i] = s.length===0? 0 : index-i; 
           s.push(arr[i]);
           
        }
       return res;
     }

3. 下一个更大元素II ： 在I的基础上将数组改为环形

   【核心】： 将数组元素翻倍
   
   function nextGreaterElements(arr){
       let n =arr.length;
       let res = [];
       let s = [];
       
       for(let i =2*arr.length-1; i>=0 ; i--){
           while(!s.length && s[n]<arr[i%n]){
               s.pop();
           }
           
           res[i%n] = s.length===0? -1 : s[n];   // 随着遍历会覆盖
           s.push(arr[i%n]);
   }
       
   【循环数组】： arr.length-1%n ===  arr.length-1;
               arr.length%n === 0
   

```

```java
895 最大频率栈
    
class FreqStack{

 // 在栈中加入一个元素 val
public void push(int val)｛｝;

// 从栈中删除并返回出现频率最高的元素
// 如果频率最高的元素不止一个，返回最近添加的那个元素
public int pop()｛｝
}

【难点】：  1. 增加变量maxFreq记录当前栈中最高的频率
          2. 频率frq对应的元素有哪些，他们有时间顺序
          3. 随着pop调用，每个val对应的频率会变化所以需要维持一个映射记录val对应的freq。
    
【数据结构设计】：   1. maxFreq记录最大频率
                 2.  Hash表， 记录 val ->  freq
                 3.  Hash表   记录 freq -> Stack
                 每次【push】【pop】都会修改freq
    
class FreqStack {
    // 记录元素的最大频率
    int maxFreq = 0;
    // 记录 每个 val 对应的出现频率，后文就称为 VF 表
    HashMap<Integer, Integer> valToFreq = new HashMap<>();
    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表
    HashMap<Integer, Stack<Integer>> freqToVals = new HashMap<>();
    
    public void push(val){
        
       int freq = valToFreq.getOrDefault(val, 0) + 1;
       valToFreq.put(val, freq);
       
       freqToVals.putIfAbsent(freq, new Stack<>());
       freqToVals.get(freq).push(val);
       // 更新 maxFreq
        maxFreq = Math.max(maxFreq, freq);
    }
    
   public int pop(){
      
       Stack<Integer> vals = freqToVals.get(maxFreq);
       int v = vals.pop();
       // 修改 VF 表： v对应的freq减一
       int freq = valToFreq.get(v)-1;
       if(vals.isEmpty()){    
           maxFreq--;
       }
       
       return v;
      
   }
}
```

###  单调队列

```javascript
239 滑动窗口最大值(困难)： 给你输入一个数组 nums 和一个正整数 k，有一个大小为 k 的窗口在 nums 上从左至右滑动，请你输出每次窗口中 k 个元素的最大值。


【单调队列】：必须使用一种数据结构支持在头部和尾部进行插入和删除。使用双向链表来完成。
       function MonotonicQueue{
          this.biList = new biList;    
       }
       MonotonicQueue.prototype.push = function(val){
           
           while(!biList.isEmpty() && biList.getLast()<val ){
                     biList.pop();
           }
               
       }
       MonotonicQueue.prototype.max = function(){
              return biList.getFirst();
       }
       MonotonicQueue.prototype.pop = function(n){
             if(n === this.biList.getFirst()){
                  this.biList.popFirst();
             }
       }

【滑动窗口最大值】：
     【步骤】： 1. 先填 k-1 个数据 单调队列第一个值是最大值
              2. 填入新的数据
              3. 返回最大值
              4. arr[i-k+1]滑动串口第一个值
                 若arr[i-k+1] != 队列第一个值证明被挤压走了，此时不用删除。
     
      function maxSlideWindow(arr, k){
          let window = new MonotonicQueue();
          
          for (let i = 0; i < arr.length; i++) {
              if (i < k - 1) {
                  //先把窗口的前 k - 1 填满
                  window.push(arr[i]);
              } else {
                  // 窗口开始向前滑动
                  // 移入新元素
                  window.push(nums[i]);
                  // 将当前窗口中的最大元素记入结果
                  res.add(window.max());
                  // 移出最后的元素
                  window.pop(arr[i - k + 1]);
              }
          }
          
      }
       
       



```

![img](https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97/1.png)

### 栈队列相互实现

```
232 用栈实现队列 (简单)
225 用队列实现栈 (简单)

【栈】：  先入先出
【队列】： 先入后出

栈模拟队列：
【入队】：向栈1添加
【出队】：栈1 ->(若栈2为空) 栈2 -> 栈2.pop



队列模拟栈：双向链表
[入栈] -> 

```

### 数学运算

#### 异或

```
任何数和 0 做异或运算，结果仍然是原来的数，即 aa⊕0=a。
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
异或运算满足交换律和结合律，即a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。
```



### 地图

#### 数据结构

```
【数组】
    数组原地去重问题 ： 有序数组原地去重采用滑动窗口
                     无序数组去重保持最大有序，采用单调栈的方法。
    
    n数之和：  两数之和，数组有序： 双指针，left = 0  right = arr.length
              两数之和，数组无序： 利用Map数据结构查找差值是否存在于数组中
              
    滑动窗口问题： 包含目标的最小小子串长度
                 s2中是否包含s1(s1可以是任何顺序)

【链表】
  
   回文链表：  1. 递归方法(类似于将数据压栈，退栈此时得到链表末端数据，再与前端数据比较)
             2.  reverse(中间， 末尾)对两段数据进行回文比较
   
   链表反转：  1. 反转整个链表：  
                 方法一： 递归法，递归函数的作用是将该节点之后的链表反转。 递归需要返回头节点
                 方法二： 迭代法，利用pre cur next指针进行链表反转，初始pre = null cur = head
                         next = head.next。
                         迭代的核心： cur.next = pre;
                                    cur = next;
                                    next = next.next
                                    
             2. 反转链表前半部分：  reverse(0, length-n);  （0<n<length）
                  注意： 前半部分反转，head元素的next指针要指向后半部分。 
                  方法一： 迭代法， 利用pre，cur，next指针进行链表反转  count用于计数
                          while(count <= border) { }  head.next = cur; head = pre
                          (在当前条件下， 循环接受pre是border节点)
                        
                 
             3. 反转链表中间部分：  reverse(0+n1, length-n);  (0<n1<length-n2)  
             
   回文链表：  1. 检测环  快慢指针，快指针的速度是慢指针速度的两倍， 根据是否相遇来进行判断
             2. 判断环的起始位置。 相遇时：slow指针行走K， fast指针行走2k, 环的起点距离
                快慢指针相遇点是m。 环内长度是K(快指针比慢指针多走了一圈，这一圈的长度就是k)
                所以抵达相遇点后， 剩余路段是k-m 刚好等于从起点到环的起始位置的距离。

【二叉树】
     a. 前序遍历、 中序遍历、 后序遍历
     
     b. 构建二叉树      
        方式：前序遍历   构造的根节点开始
        
     c. 二叉树转化为单链表 
        方式：后序遍历
        
     d. 二叉树的序列化和反序列化    
        序列化：按照某种遍历方式遍历并生成字符串  
        反序列化：按照字符串构建树
        
     e. 子树的收集       【最小子树】：叶子节点为null
        后序遍历，通过字符串进行保存放入到 Map 结构中，用于判断是否有重复子树。  
  
     f. 递归： 每个节点进行相同的操作，需要对特殊节点进行单独判断和操作。
  
【二叉搜索树】

【n叉树】

【栈】

【队列】

【堆】

【哈希表】

```

#### 算法

```
【动态规划算法】
     1. 【我思维】
         
         【思维】： a. 在无规则的情况下人是无法作出随机选择，人的选择一定是按照某种规则。
                  b. 生活中的n元问题，先确定某个单变量进而确定其它变量。
                  c. 对于有限制的选择最大利益，我习惯性先考虑满足最大利益，再去看是否符合限制
                     另外一种很少尝试： 首先满足限制，再去选择利益最大化的方式。
           dp 数组： the value of statue is the Max/Min [noun] from [starPos，curPos] 
                    当下信息去推导未来，for循环。 当下信息dp[i][j]存储的状态值。
           dp 函数： the value of statue is the Max/Min [noun] from [curPos, endPos] 
                    未来信息去推导过去，递归。 未来的信息便是递归函数的返回值
    
 动态规划算法：

  1. 子序列类型问题
     【编辑距离】： 给定两个单词word1 和 word2， 计算word1转化为word2需要的最少操作， 你可以用到
                 的操作时插入、 删除、 替换。
           分析： 程序的[索引是我们的（眼睛）和（手指），用两个索引指向两个字符串的末尾，此时可以进行
                 删除/替换/插入， 因此采用动态规划的方法同时执行这三种操作， 找到需要最小操作数的流
                 程。 因为题目是最少操作数， 我们用指针的变化来代替操作
           dp(i,j){
                if(i === -1) return j+1;
                if(j === -1) return i+1;
               
               if(str1.charAt(i) === str2.charAt(j)){
                   return dp(i-1, j-1);
               }else{
                   return Math.min(
                     dp(i, j-1)+1，    // 插入
                     dp(i-1, j)+1，    // 删除
                     dp(i-1, j-1)+1    // 替换 
                   )
               }
           }
 
      【最长上升子序列】：给一个整数数组，找到其中最长的严格递增子序列的长度 [10,9,2,5,3,7,101,18]
                分析： 程序的（索引）是我们的眼睛和手指，以当前索引指向为起始向后寻找递增数
                      进行选择时总有n-i种选择，不知道哪一种长度更长，因此采用for循环全部尝试
                      找到需要的最大操作数。
                分析2： 采用dp数组， 状态值以当前数为结尾最大子序列长度。
               dp(i, cmp){
                   if(i >= num.length ) return 0;
                   let max_num = 1;
                   
                   for(let j=i; i<num.length;i++){
                       if(num[i]<cmp) continue;
                      var fu = dp(i+1, num[i]);
                       max_num = Math.max(max_num, fu+1)；
                   } 
                   return max_num
               }
              dp   "" , 10, 9, 2, 5, 3, 7, 101, 18
                    0 ,  1, 1, 1, 2, 2, 3,  4 ,  4 
               dp=[];  dp[0] = 0;
               for(let i=1; i<=num.length;i++){
                   for(let j=i; j<0; j--){
                       if(num[i-1] > num[j-1])
                         max_num = Math.max(max_num, dp[j-1]+1);
                   }
                   dp[i] = max_num;
               }
                let res = 0;
                for (int i = 0; i < dp.length; i++) {
                    res = Math.max(res, dp[i]);
                }
                return res;
      
    【俄罗斯套娃信封问题】：(w,h) 宽度和高度确定的信封， 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里， 如同俄罗斯套娃。
             分析： 将信封宽度按照从小到大的顺序，宽度一致的话，高度按照从大到小的顺序摆放。
                   进过宽度预处理后，便可以使用最长上升子序列的方法去得到结果。
    
     【最大子序和】： 一个整数数组nums， 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回
 其最大和。  [-2, 1, -3, 4, -1, 2, 1, -5, 4]
          分析：  连续子数组的和若数组全为正数，则最大和是整个数组累加和， 由于负数的出现
                 最大和是连续正数相加。 
          方法1. 计算当前位置及之前的最大值， 使用dp数组的形式： 状态：当前位置  值：最大值
               -2 1 -3 4 -1 2 1 -5 4    当前最大值<0 , 后一个值的最大值将会是其本身
               -2 1 -2 4  3 5 6 -1 3 
          dp = [];  dp[0] = -2
          for(let i =1 ; i < nums.length; i++){
              dp[i] = dp[i-1] < 0? nums[i]: dp[i-1]+nums[i];
          }
          let res = 0;
          for (let i of dp){
              res = Math.max(res, i);
          }
          return i 
     【最长公共子序列】： 给定两个字符串 text1 和 text2 ，返回这两个字符串的最长
                      公共子序列， 如果不存在公共子序列， 返回0.
             text1: ebcfdvabc    text2: abc
               分析：  按照 text2 的字母顺序， 在 text1 中寻找最长的相对顺序不变的最长公共序列
                      在两个字符串上放置两个索引作为👀+手指， 如果两个索引指向的值相同， 则共同前进
                      但是当两个值不同时， 此时有两种情况： text1： 指针前进， text2：不动； 
                      text1: 指针不动， text2：指针前进。
               status: (i,j)    value: max length
               
               dp(i, j){
                   if(i > S1.length || j < S2.length) return 0;
                   let str = String(i) + String(j);   let vv;
                   if(memo.has(str)) return memo.get(str);
                   if(S1.chaAt(i) === S2.charAt(j)){
                        vv = dp(i+1, j+1)+1
                   }else{
                       vv = Math,max(
                         dp(i, j+1)+1,
                         dp(i+1, j)+1
                       ); 
                   }
                   memo.set(str, vv);
                   res = Math.max(res, vv);
               }
         最长公共子序列：递归本身的状态值是操作步骤数，其返回之后的操作步骤。
         
        【字符串的删除操作】： 给定两个单词 s1 和 s2 找到使得 S1 和 S2相同
                           所需要的最小步数。
                    分析： s1 和 S2 保留最长的公共子序列，则删除的步骤最少
                          因此可以利用【最长公共子序列】的结果len
                     res = S1.length-len + S2.length.len 

  2. 背包类型问题

   【背包问题】： 
               [0-1背包]： 可装载重量为W的背包和N个物品， 每个物品有重量和价值，第i个
                          物品重量为wt[i]， 价值为val[i]，求用这个背包装的最大价值
                          是多少。
                    分析： 在不超过背包的重量之下获得的最大价值， 关键点是选取的转态
                          对于前 i 个物品， 背包容量为 w 时， 背包装载的最大价值。
                    初始状态： dp[0][...] = 0    dp[...][0] = 0
                     状态值：  if( w-wt[i-1] < 0 ){
                                 dp[i][w] = dp[i-1][w]
                              }else{
                                 dp[i][w] = max(
                                            dp[i-1][w-wt[i-1]] + val[i-1],
                                            dp[i-1][w]
                              }
              [分割等和子集]：给定一个只包含正整数的非空数组， 将两个元素分割成两个子
                            集，使两个子集的元素和相等. [1,5,11,5] 数组可以分割成
                            [1,5,5] 和 [11]
                      分析： 子集分割首先转化为是否存在一个子集, 其累加和等于
                                            target/2
                      翻译成背包问题： 给定N个物品， 每个物品的重量为nums[i],是否存
                                    在一种装法，当背包重量为w 使得背包恰好装满。
                         初始状态： dp[0][...] = fasle   dp[...][0] = true
                          状态值：     if( w - wt[i-1] < 0){
                                         dp[i][w] = dp[i-1][w];
                                      }else{
                                         dp[i][w] = dp[i-1][w] || dp[i-1][w-wt[i-1]]
                                      }
                                      
              [零钱兑换II]：   给定不同面额的硬币和一个总金额，假设每种硬币的数量
                             是无限个， 写出可以凑成总金额的硬币组合数。
                      分析：  使用前 i 个硬币， 总金额为 j 时， 共有的金币组合数
                             该类型的题的最大特点： 子集的取法是穷举所有可能，统
                             计满足 amount 限制的组合。 
                    初始状态： dp[0][...] = 0  dp[...][0] = 1
                     状态值：  if( w - wt[i-1] < 0){
                                     dp[i][w] = dp[i-1][w];
                                }else{
                                     dp[i][w] = dp[i-1][w] + dp[i-1][w-wt[i-1]]
    
  🎒问题与【编辑距离】、【最长公共子序列】都是找寻符合条件的子序列，后者的状态值是当前位置， 背包问题的
  状态值：前 i个 xx、背包重量 N， 当你确认好前1个， 前2个状态值只需要确认当前的重量属性，然后利用上一
  个状态。 

  3. 贪心类型问题
 


  4 .用动态规划玩游戏
        【最小路径和】：一个二维数组 grid， 元素都是非负整数, 站在左上角，只能向右或者
                     向下移动，需要到达右上角。计算经过的路径和最小是多少  m * n
                     grid = [[1,3,1],[1,5,1],[4,2,1]]   out:7
                     1 3 1
                     1 5 1
                     4 2 1
             分析： 行索引 和 列索引作为程序的眼睛和手指， 路径和最小因此需要遍历所有路径，且遍历
                   方式题目已经给出: 每个方块有两种走法：left 和 down， 因此都需要完成遍历才可
                   决定哪条路径最小， 递归返回的状态值： 此种走法之后路径和。 
                   dp（i, j）{
                       if(i === m-1 && j === n-1){
                           return grid[i][j];
                       }
                       if(i > m-1 || j > n-1){
                           return Number.Max_Value;
                       }
                       let str = String(i) + " " + String(j);
                       if(memo.has(str)) return memo.get(str);
                       
                       let res = Math.min(
                            dp(i+1, j),
                            dp(i, j+1)
                       ) + grid[i][j]
                       memo.set(str, res);   
                       return res;
                   }
            如果利用 dp 数组的方法， 状态： 当前矩阵的位置， 状态值： 当前位置为终点时最小路径和
                    dp[0][0] = grid[0][0];
                    for (int i = 1; i < m; i++)
                        dp[i][0] = dp[i - 1][0] + grid[i][0];

                    for (int j = 1; j < n; j++)
                        dp[0][j] = dp[0][j - 1] + grid[0][j];        
                    /*******************/
                    // 状态转移
                    for (int i = 1; i < m; i++) {
                        for (int j = 1; j < n; j++) {
                            dp[i][j] = Math.min(
                                dp[i - 1][j],
                                dp[i][j - 1]
                            ) + grid[i][j];
                        }
                    }
          【魔塔问题】： 地下城是由 M*N 个房间组成的二维网络， 骑士从左上角
                      出发到右下角拯救公主。 每个房间都是一个整数， >0是
                      ➕血， <0是－血 =0 普通房间， 问骑士最少需要多少初始
                      血量， 必须保证骑士最大血量>0。
               分析：  此题基于的是【最小路径和】的模板， 状态：房间位置， 状态值：
                      此种路径需要的最少血量。
                      
             dp（i, j）{
                       if(i === m-1 && j === n-1){
                           return grid[i][j]>=0? 1: -grid[i][j]+1;
                       }
                       if(i > m-1 || j > n-1){
                           return Number.Max_Value;
                       }
                       let str = String(i) + " " + String(j);
                       if(memo.has(str)) return memo.get(str);
                       
                       let res = Math.min(
                            dp(i+1, j),
                            dp(i, j+1)
                       ) - grid[i][j];
                       res = res <= 0? 1 : res 
                       memo.set(str, res);   
                       return res;
                   }
       【高空扔鸡蛋】： 从 1 到 N 共 N 层楼， 一共K个鸡蛋(K 至少为1)。 将鸡蛋扔下去， 高于F层鸡蛋
                     一定碎， 低于F层的鸡蛋一定不会碎， 问最小用几颗鸡蛋把这层楼 F 找到。
               分析： 若没有鸡蛋限制， 直接使用二分搜索法，可以得到最小的次数。
               
        【戳气球】：n 个 气球，编号为0 - n-1, 每个气球都标有一个数字， 这些数字存在数组nums
                  每次戳破一个气球可以获得 nums[left] * nums[i] * nums[right], 求能获得的硬
                  币的最大数量。  例如 [3, 1, 5, 8]  (可以设 nums[-1] = nums[n] =1)
             分析： 戳气球的数量是任意， 可以是1个可以是2个及以上， 最大硬币数是所有可能的删除策略的
                   结果。 所有可能的删除策略： 不删除， 删一个， 删两个， 删除 n-1 个
                   
         【石子游戏】： 你和你朋友面前有一排石头堆，用一个数组piles， piles[i]表示第i堆石子
                      有多少个，轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。
                      石头被拿完后，谁拿走的石头多谁获胜。
                     piles: [3,9,1,2]  
               分析： 当我们使用dp数组时， 状态：堆的起始点，堆的截止点，first/second
                     状态值：选手获得的最大值。
                     left  = piles[i] + dp[i+1][j][second] 
                     right = piles[j] + dp[i][j-1][second]
                     dp[i][j][0] = Math.max(left, right);
                     if(dp[i][j][0] == left){              当第一人选择左边时
                         dp[i][j][1] = dp[i+1][j][0];
                     }else{                                当第一人选择右边时
                         dp[i][j][1] = dp[i][j-1][0];
                     }
                     dp[i][j] 需要依靠该元素左边第一个和下边第一个值， 因此在遍历 dp 数组时是斜着
                     遍历。
        
        【股票问题】： [3, 2, 6, 5, 0, 3],  k=2     输出7
                  一个人在规定期限内： 进行 买入、 卖出操作，在至多交易次数的限制下，问能获得多少利
                  润。
                  
             分析： 利用状态方程， 天数、 是否持有、 交易限制为交易过程中的状态， 状态值是最大利润。
                  若交易限制为无限制：
                          dp[i][0] = max(dp[i-1][0], dp[i-1][1]+price[i]);
                          dp[i][1] = max(dp[i-1][1], dp[i-1][0]-price[i]);
                                    
                   若交易限制为1次则：
                          dp[i][0] = max(dp[i-1][0], dp[i-1][1]+price[i]);
                          dp[i][1] = max(dp[i-1][1],    -price[i]);
                       初始状态：
                           dp[0][0] = 0
                           dp[0][1] = -INF   表示不可能
                    若交易限制k次则：
                          dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+price[i]);
                          dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-price[i]);
                       初始状态： 
                          dp[0][k][0] = 0
                          dp[0][k][1] = -Inf
                          dp[..][0][0] = 0       // 此时交易限制为0 无法交易利润为0
                          dp[..][0][1] = -Inf
                   若交易无限制,有冷冻期1天：
                          dp[i][k][0] = max(dp[i-1][0], dp[i-1][1]+price[i]);
                          dp[i][k][1] = max(dp[i-1][1], dp[i-2][[0]-price[i]); 
                    注：dp[i-1][k-1][0]  = max(dp[i-2][0], dp[i-2][1])
                   若交易无限制,有手续费：
                          dp[i][k][0] = max(dp[i-1][0], dp[i-1][1]+price[i]-fee);
                          dp[i][k][1] = max(dp[i-1][1], dp[i-1][0]-price[i]); 
          【打家劫舍】问题：
                   1. 专业小偷每间房间藏有一定的现金， 相邻房间连有报警系统不能同时抢劫
                      问小偷当晚偷盗的最大金额
                    输入：[1,2,3,1]  输出:[4]
                 分析： 股票问题相似， 哪一天持有/卖， 变成哪一件房子偷/不偷， 且股票的
                       的冷冻期这里是相邻房间不能偷， 因此递归时状态： 当前房间位置
                       选择： 偷/不偷
               a.  function dp(n){
                       if(n> nums.length){
                           return 0;
                       }
                       
                       let res = -1;

                       let m = Math.max(
                               dp(n+1),
                               dp(n+2)+nums[n])
                            res = Math.max(res, m);
                       return m;
                   }  
              b.  dp 数组， 状态：第i个房间偷或者不偷获得的最大值
                     dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
                     dp[i][1] = max(dp[i-1][0]+nums[i-1], dp[i-2][1]+nums[i-1]);
                     
              2. 首尾房间相连
              分析： dp数组针对两个数组 nums[0:n-2] 、 nums[1:n-1], 分别计算最大值再
                    统一去比较
                    
         
        【动态规划之KMP字符串匹配】：str 和 pat (JS 中的indexOf函数)
            1. 暴力解法： 用索引作为操作str 和 pat的眼睛和手， 两个索引同时运动(在一个循环中)， 若字符串
                        不匹配则，str回退到起始位置的下一个点继续遍历
                  // 暴力匹配（伪码）
                                function search(String pat, String txt) {
                                    let M = pat.length;
                                    let N = txt.length;
                                    for (int i = 0; i <= N - M; i++) {
                                        int j;
                                        for (j = 0; j < M; j++) {
                                            if (pat[j] != txt[i+j])
                                                break;
                                        }
                                        // pat 全都匹配了
                                        if (j == M) return i;
                                    }
                                    // txt 中不存在 pat 子串
                                    return -1;
                                }
         2. dp数组
     
     2. 【数学】
                    
     
     3. 【代码】： (框架、核心步骤、数据结构、可优化)
     
            

【回朔算法】
     1. 【我思维】
        
        【按照规则进行选择】- 【记录选择】 - 【信息检验】 - 【回退】
        
     2. 【数学】
     
         穷举法
     
     3. 【代码】： (框架、核心步骤、数据结构、可优化)
     
           
         

【二分搜索】
     【范畴】： 通过二分搜索，目标可以缩小到更小的区间上
              1. 有序数组， 二分可以确定 target 所在的有序区间
              2. 寻找峰值， 二分搜索可以判断出峰值所在的区间
          
     【我思维】: left 指针与 right 指针推出 mid 指针，与target进行比较，决定移动 left 指针或者是
                right 指针。
         
                
      【数学】:
      
            针对有序数据集合【遍历】加入了方向性，更快的搜索到目标对象。
            有序：属性用数字去量化。
            
      【代码】： 
          搜索到目标：
              left = 0;   right = nums.length-1
               while(left <= right){
                  mid = left + (right - left)/2;
                 if(nums[mid] < traget){
                     left = mid +1 ;
                 }else if(nums[mid] > target){
                     right = mid-1;
                 }else if( nums[mid] == target){
                     return mid
                 }
               }
          搜索目标左边界：   left 永远不可能为 -1；
              left = 0; right = nums.length-1;
               while(left <= right){
                  mid = left + (right - left)/2
                  if(nums[mid] < target){
                     left = mid + 1;
                  }else if(nums[mid] > target){
                     right = mid - 1;
                  }else if(nums[mid] === target)
                     right = mid - 1;
               }
               if(left >= nums.length || nums[left] != target) return -1;
               return left;
          搜索目标右边界：
               left = 0; right = nums.length-1;
               while(left <= right){
                  mid = left + (right - left)/2;
                  if(nums[mid] < target){
                    left = mid + 1;
                  }else if(nums[mid] > target){
                    right = mid - 1；
                  }else if(nums[mid] == target){
                    left = mid + 1；
                  }
               }
               if(right < 0 || nums[right] !== target) return -1
               return right;
      【实际问题】： 未知量可能取值是有序集合，例如[0, +00]利用二分搜索法快速定位满足限制条件的结果。
      
【双指针技巧】
         
         【思考】：二分搜索也可以看做是双指针的一种类型，核心思想是一种贪心策略，根据当下
                 的线索去选择利益更大的区间。
   
     

【滑动窗口技巧】

    【我思考】： 两人协同在一维空间中搜寻某个目标：一人留守，一人前行，满足条件后留守人向前行。
               任务需要一个模板，同时需要记录当前收集到的有效元素。
  
    【代码】：
               let left = 0;
               let right = 0;
               let goldMap = new goldMap();
               let rr = new Map()
               
               for(let i of strr){
                  // 生成模板
               }
               
               while(right < strr.length){
                  
                  let c = strr[right];
                  right++
                  
                  if(goldMap.has(c)){
                       
                       if(map.has(c)){
                           // 设置数量1
                       }else{
                          // 设置数量递增
                       }
                       
                       if(map.get(c) <= goldMap.get(c)){
                           count++;
                       }
                  } 
     
                  while(收缩条件){
                     let d = strr[left];
                     left++;   
                  }
     
     
【BFS算法】

【分治算法】

【快排思想】

【桶排序思想】

【索引排序思想】
```

#### 汇总

第二阶段熟悉的算法：

​     （*二分搜索*、左边界、右边界）、（*快慢指针*：有序数组去重、移除元素、链表判环）、

​     （*双指针*：有序n数之和、回文判断）、（*滑动窗口*：字符串最大无重复， 字符串最小子串匹配pat）

​       （*三指针*：链表反转、链表部分反转）、（*回朔算法*）、（*动态规划算法*）

第二阶段熟悉的数据结构：

​        （*二叉树*： 前序遍历、中序遍历、后序遍历、二叉树一维化、 构建二叉树）

​         （二叉堆：数组堆化、 优先队列、 计算中位数、 返回第K大元素）

​         （单调栈： 从后遍历数组入栈，若当前元素小于栈顶元素退栈，直到栈为空或者栈顶元素大于当前元素）。
