### 垃圾回收机制

```javascript
1.  JavaScript 垃圾回收的机制
     . 标记清除法
     . 引用计数
     
2. 标记清除法：
     .标记方式： 特殊位的反转、 维护一个列表
     .垃圾收集器在运行的时候会给存储在内存上的所有变量加上标记，然后它会去掉环境中的变量， 栈中引用的变量， 在此之后再被标记的变量将被视作准备删除的变量。 最后垃圾回收器清楚标记的变量，回收他们所占用的空间。
     . 目标主流浏览器都是使用标记清楚方式的垃圾回收策略
     . 标记-清除法清除局部变量 和 全局对象声明为 null 的变量。
     
3. 引用计数
     .原理：每次声明变量赋予引用值时加1，同一个值被赋予另外的变量时加1， 保存
           对该值引用的变量被其他值覆盖时减1。引用次数变成0，将其内存空间收
           回。
     局限：若是循环引用则各自属性相互引用两个对象引用次数都是2。
      let a = new Object();
      let b = new Object();
           
4. V8 堆的构成： 新生区、 老生区、 大对象区、 代码区

         新生区： 大多数对象存在这里， 区域大小 1-8Mb
         老生区： 在新生区待一定时间的对象会被挪移到这里
         大对象区： 存放体积超越其他区的对象，垃圾回收从不移动此空间对象
         代码区： 
         
5. v8 回收机制： 分代回收
          使用指针，新对象进入新生区被填满后，会回收掉不活跃的对象称为1个小周期， 超过两个小周期的对象会被移动到老生区，老生区的回收是在移动足够多的新生对象
之后。
      新生区： Scavenge 算法
              新生代：闲置的空间，处于使用状态的空间。 检测处于使用的空间是否
                     满，若满了使用垃圾回收算法。检查存活的对象是否符合晋升
                     条件，符合将其引入到老生区，不符合将其引入到闲置空间
                     中。晋升条件是 闲置空间使用超过
                     25%，同时经历了一次 scavenge 算法。
                  
      老生区： 标记-清除  &  整理
               
      老生代在进行标记清除算法后，容易造成内存碎片，因此使用对内存整理，整理算法将活跃的对象往边界移动，移动完成后再进行垃圾清除。
  
6. 内存泄漏问题：  对象不被使用了，但是无法被回收。
       a. 意外的声明全局变量, 变量被声明为全局变量不会被垃圾回收掉
          全局变量如果希望被清除需要赋值为 null

       b. 定时器：定时器的回调通过闭包引用了外部变量，如果定时器不清除
                变量会一直占用内存
                
       c.  事件监听： 监听函数对事件监听，并在回调函数中使用外部变量，若没有清除监听函数则会导致
                    内存泄漏问题。
                 解决方法： 使用 addEventListener 和 removeEventListener 
                 
                 const hugeString = new Array(100000).join('x');

                 document.addEventListener('keyup', function() {
                     // anonymous inline function - can't remove it
                      doSomething(hugeString);
                     // hugeString is now forever kept in the callback's scope
                 });

           定时器和事件监听都是在回调引用了外部变量，在未清除前垃圾回收不能回收变量使用的内存。
                
       c.  闭包： 闭包本身不会造成内存泄漏，它只是将局部变量保存在了闭包作用域中
                 只要内部函数引用了外部变量，就会形成闭包作用域。
                 
            . 内存泄漏的原因之一： 低版本 IE 浏览器的 dom 对象是参考 C++ 的 com 对象
                               实现，其垃圾回收机制是引用计数法，而闭包十分容易引起
                               循环引用，导致 dom 对象无法回收。
            . function assignHandler(){
                    var element = document.getElementById("someElement");
                    element.onclick = function(){
                        alert(element.id);
                    };
              }
            . 目前大多数浏览器都是采用标记-清除的方法，会标记所有存储在内存中的对象，经过一轮标记
              删除(可达对象)， 对依然被标记的对象进行回收。
               
       
7. 内存调试工具：
       . 内存调试工具很难判断该内存是否不再需要，通常会多次执行某段逻辑， 隔一段时间进行一次
         内存 dump 判断内存是否存在不断增长趋势。
                 
```

