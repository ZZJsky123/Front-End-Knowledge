## 浅拷贝

```javascript
function shallow(obj){
   let cloneobj = {};
   
   if (obj === null){
     return obj
   }
   else if (typeof obj === 'object'){
     for (let i in obj){
        if (obj.hasOwnProperty(i) && Object.getOwnPropertyDescriptor(obj, i)['enumerable'] === true)
         cloneobj[i] = obj[i]
     }
   }
   else{
     cloneobj = obj
   }
   
   return cloneobj
}
```

```
Object.assign(target, copyobj)   // JS原生提供的浅拷贝方法，只复制对象自己的属性且该属性必须可迭代。
                                 // assign方法将copyobj的属性复制到target中，支持对个copyobj
                                 // 在复制过程中，若存在同名属性则后边覆盖前边。
Object.assign(target)            // 单个参数若是对象则直接返回，不是则先包装成对象再返回
                                 // Object.assign(null/undefined) 不可包装成对象报错
Object.assign(target, nonobj)    // nonobj只有是字符串的情况下才不会被忽略按数组返回的方式返回
                                    因为只有字符串的对象属性是可迭代的。
```



## 深拷贝

```javascript
function deepclone(obj){
   
   if( obj === null) return obj;
   else if(obj instanceof Date === 'Date') return new Date(obj);
   else if(obj instanceof RegExp === 'RegExp') return new RegExp(obj);
   else if(typeof obj !== 'object') return obj
   
   let cloneobj = new obj.constructor();
   
   for (let key in obj){
     if (obj.hasOwnProperty(key)){
          cloneobj[key] = deepclone(obj[key]);
     }
   }
    return cloneobj;
}
```

```
JSON.stringify() 实现深拷贝缺陷

1. RegExp ERROR对象为空

2. function、undefined 会被丢弃

3. NaN， infinited ，会被置null

4. 存在循环引用会报错

5. 存在相同引用，会指向不同内存空间
```

