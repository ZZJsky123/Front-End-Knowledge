## 浅拷贝

```javascript
function shallow(obj){
   let cloneobj = {};
   
   if (obj === null){
     return obj
   }
   else if (typeof obj === 'object'){
     for (let i in obj){
        if (obj.hasOwnProperty(i) && Object.getOwnPropertyDescriptor(obj, i)['enumerable'] === true)
         cloneobj[i] = obj[i]
     }
   }
   else{
     cloneobj = obj
   }
   
   return cloneobj
}
```

```
Object.assign(target, copyobj)   // JS原生提供的浅拷贝方法，只复制对象自己的属性且该属性必须可迭代。
                                 // assign方法将copyobj的属性复制到target中，支持对个copyobj
                                 // 在复制过程中，若存在同名属性则后边覆盖前边。
Object.assign(target)            // 单个参数若是对象则直接返回，不是则先包装成对象再返回
                                 // Object.assign(null/undefined) 不可包装成对象报错
Object.assign(target, nonobj)    // nonobj只有是字符串的情况下才不会被忽略按数组返回的方式返回
                                    因为只有字符串的对象属性是可迭代的。
```



## 深拷贝

```javascript
a. 深度拷贝解决 循环引用 和 相同引用 问题

b. 
   .相同引用： obj = {a:{}, b:a}, 属性 b 和 属性 a 指向相同的引用
   .循环引用： obj = {a:{b：a}} , 属性 a 有一个属性 b, 属性 b 中也拥有属性a 
   .相同引用需要保证深度复制后，两个对象也可以互相改变。不考虑相同引用，深度复制会导致
    两个新的对象， 因此需要保证第一次是新建对象， 第二次识别是相同引用，赋值第一次新建
    的对象。
   .循环引用在深度拷贝会引起无限递归，在对 b 下的属性进行遍历，并遍历到 a 的时候应该直接
    返回 a 的新对象

function deepCopy(obj){
    
    let memo = new Map();       // 使用记忆数组： key：oldObj  value：newObj
 
    return _deepCopy(obj);
    
    function _deepCopy(obj){
       
        // 基本类型判断
        if(obj === null) return obj;
        if(typeof obj !== 'object') return obj;
        
        // 检测是否重复依赖
        if(memo.has(obj)) return memo.get(obj); 
        
        let cloneObj = new obj.constructor();
        memo.set(Obj, cloneObj);
        
        // 元素是对象
        if(!Array.isArray(obj)){
           for(let i in obj){
               if(obj.hasOwnProperty(i)){
                   cloneObj[i] = _deepCopy(obj[i]);
                }
          }
        }else{
         // 元素是数组
           for(let i of obj){
           cloneObj[i] = _deepCopy(obj[i]);
           }
        }
      return cloneObj;   
    }
    
}
```

```
JSON.stringify() 实现深拷贝缺陷

1. RegExp ERROR对象为空

2. function、undefined 会被丢弃

3. NaN， infinited ，会被置null

4. 存在循环引用会报错

5. 存在相同引用，会指向不同内存空间
```



